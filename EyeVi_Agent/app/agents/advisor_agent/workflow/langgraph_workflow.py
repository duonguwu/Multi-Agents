from typing import Dict, List, Any, TypedDict
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from langchain_core.messages import BaseMessage
import os

from utils.pdf_processor import PDFProcessor
from utils.embedding_manager import EmbeddingManager
from utils.qdrant_manager import QdrantManager
from agents.rag_agent import RAGAgent

class WorkflowState(TypedDict):
    """
    ƒê·ªãnh nghƒ©a state cho LangGraph workflow
    """
    # Input
    query: str
    pdf_paths: List[str]
    
    # Processing state
    documents: List[Dict]
    query_embedding: List[float]
    retrieved_documents: List[Dict]
    
    # Output
    answer: str
    sources: List[str]
    relevant_docs_count: int
    error: str
    
    # Status
    step: str
    messages: List[BaseMessage]

class PDFRAGWorkflow:
    def __init__(self):
        """
        Kh·ªüi t·∫°o LangGraph Workflow cho h·ªá th·ªëng PDF Q&A
        """
        print("üöÄ ƒêang kh·ªüi t·∫°o PDF RAG Workflow...")
        
        # Kh·ªüi t·∫°o c√°c components
        self.pdf_processor = PDFProcessor()
        self.embedding_manager = EmbeddingManager()
        self.qdrant_manager = QdrantManager()
        self.rag_agent = RAGAgent()
        
        # T·∫°o workflow graph
        self.workflow = self._create_workflow()
        
        print("‚úÖ PDF RAG Workflow ƒë√£ s·∫µn s√†ng!")
    
    def _create_workflow(self) -> StateGraph:
        """
        T·∫°o LangGraph workflow v·ªõi c√°c nodes v√† edges
        """
        workflow = StateGraph(WorkflowState)
        
        # Th√™m c√°c nodes
        workflow.add_node("check_documents", self.check_documents_node)
        workflow.add_node("process_pdfs", self.process_pdfs_node)
        workflow.add_node("create_embeddings", self.create_embeddings_node)
        workflow.add_node("store_in_qdrant", self.store_in_qdrant_node)
        workflow.add_node("process_query", self.process_query_node)
        workflow.add_node("retrieve_documents", self.retrieve_documents_node)
        workflow.add_node("generate_answer", self.generate_answer_node)
        workflow.add_node("handle_error", self.handle_error_node)
        
        # ƒê·ªãnh nghƒ©a entry point
        workflow.set_entry_point("check_documents")
        
        # ƒê·ªãnh nghƒ©a conditional edges
        workflow.add_conditional_edges(
            "check_documents",
            self.should_process_pdfs,
            {
                "process": "process_pdfs",
                "query": "process_query"
            }
        )
        
        # ƒê·ªãnh nghƒ©a linear edges cho document processing
        workflow.add_edge("process_pdfs", "create_embeddings")
        workflow.add_edge("create_embeddings", "store_in_qdrant")
        workflow.add_edge("store_in_qdrant", "process_query")
        
        # ƒê·ªãnh nghƒ©a edges cho query processing
        workflow.add_edge("process_query", "retrieve_documents")
        workflow.add_edge("retrieve_documents", "generate_answer")
        workflow.add_edge("generate_answer", END)
        workflow.add_edge("handle_error", END)
        
        return workflow.compile()
    
    def check_documents_node(self, state: WorkflowState) -> WorkflowState:
        """
        Node ki·ªÉm tra xem c√≥ c·∫ßn x·ª≠ l√Ω PDFs kh√¥ng
        """
        try:
            state["step"] = "Ki·ªÉm tra t√†i li·ªáu"
            print("üìã Ki·ªÉm tra tr·∫°ng th√°i collection v√† PDFs...")
            
            # Ki·ªÉm tra collection info
            collection_info = self.qdrant_manager.get_collection_info()
            
            if "error" in collection_info:
                # Collection ch∆∞a t·ªìn t·∫°i, c·∫ßn x·ª≠ l√Ω PDFs
                state["step"] = "C·∫ßn x·ª≠ l√Ω PDFs"
                print("üìÅ Collection ch∆∞a t·ªìn t·∫°i, s·∫Ω x·ª≠ l√Ω PDFs...")
            elif collection_info.get("vectors_count", 0) == 0:
                # Collection t·ªìn t·∫°i nh∆∞ng r·ªóng
                state["step"] = "C·∫ßn x·ª≠ l√Ω PDFs"
                print("üìÅ Collection r·ªóng, s·∫Ω x·ª≠ l√Ω PDFs...")
            else:
                # Collection ƒë√£ c√≥ d·ªØ li·ªáu
                state["step"] = "Ch·ªâ x·ª≠ l√Ω query"
                print(f"‚úÖ Collection ƒë√£ c√≥ {collection_info['vectors_count']} vectors")
            
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi ki·ªÉm tra documents: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def should_process_pdfs(self, state: WorkflowState) -> str:
        """
        Conditional function quy·∫øt ƒë·ªãnh c√≥ c·∫ßn x·ª≠ l√Ω PDFs kh√¥ng
        """
        if state["step"] == "C·∫ßn x·ª≠ l√Ω PDFs":
            return "process"
        else:
            return "query"
    
    def process_pdfs_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 2.1: T·∫£i v√† Ph√¢n T√°ch T√†i Li·ªáu PDF
        """
        try:
            state["step"] = "X·ª≠ l√Ω PDFs"
            print("üìÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω PDFs...")
            
            all_documents = []
            
            if not state.get("pdf_paths"):
                raise Exception("Kh√¥ng c√≥ ƒë∆∞·ªùng d·∫´n PDF n√†o ƒë∆∞·ª£c cung c·∫•p")
            
            for pdf_path in state["pdf_paths"]:
                if not os.path.exists(pdf_path):
                    print(f"‚ö†Ô∏è File kh√¥ng t·ªìn t·∫°i: {pdf_path}")
                    continue
                
                documents = self.pdf_processor.process_pdf(pdf_path)
                all_documents.extend(documents)
            
            if not all_documents:
                raise Exception("Kh√¥ng th·ªÉ x·ª≠ l√Ω b·∫•t k·ª≥ PDF n√†o")
            
            state["documents"] = all_documents
            print(f"‚úÖ ƒê√£ x·ª≠ l√Ω {len(all_documents)} chunks t·ª´ {len(state['pdf_paths'])} files")
            
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi x·ª≠ l√Ω PDFs: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def create_embeddings_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 2.2: T·∫°o Vector Embedding cho T√†i Li·ªáu
        """
        try:
            state["step"] = "T·∫°o embeddings"
            print("üßÆ T·∫°o embeddings cho documents...")
            
            documents_with_embeddings = self.embedding_manager.embed_documents(state["documents"])
            state["documents"] = documents_with_embeddings
            
            print("‚úÖ ƒê√£ t·∫°o embeddings th√†nh c√¥ng")
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi t·∫°o embeddings: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def store_in_qdrant_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 2.3: L∆∞u Tr·ªØ Vector v√†o Qdrant
        """
        try:
            state["step"] = "L∆∞u v√†o Qdrant"
            print("üíæ L∆∞u documents v√†o Qdrant...")
            
            # T·∫°o collection n·∫øu ch∆∞a c√≥
            vector_size = self.embedding_manager.embedding_dimension
            self.qdrant_manager.create_collection(vector_size)
            
            # Th√™m documents v√†o collection
            self.qdrant_manager.add_documents(state["documents"])
            
            print("‚úÖ ƒê√£ l∆∞u documents v√†o Qdrant th√†nh c√¥ng")
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi l∆∞u v√†o Qdrant: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def process_query_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 3.1: Ti·∫øp Nh·∫≠n v√† X·ª≠ L√Ω C√¢u H·ªèi Ng∆∞·ªùi D√πng
        """
        try:
            state["step"] = "X·ª≠ l√Ω c√¢u h·ªèi"
            print(f"‚ùì X·ª≠ l√Ω c√¢u h·ªèi: {state['query']}")
            
            # T·∫°o embedding cho query
            query_embedding = self.embedding_manager.embed_query(state["query"])
            state["query_embedding"] = query_embedding.tolist()
            
            print("‚úÖ ƒê√£ t·∫°o embedding cho c√¢u h·ªèi")
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi x·ª≠ l√Ω c√¢u h·ªèi: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def retrieve_documents_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 3.2: Truy Xu·∫•t Th√¥ng Tin Li√™n Quan t·ª´ Qdrant
        """
        try:
            state["step"] = "Truy xu·∫•t documents"
            print("üîç T√¨m ki·∫øm documents li√™n quan...")
            
            # T√¨m ki·∫øm trong Qdrant
            retrieved_docs = self.qdrant_manager.search_similar_documents(
                state["query_embedding"]
            )
            
            state["retrieved_documents"] = retrieved_docs
            
            print(f"‚úÖ ƒê√£ t√¨m th·∫•y {len(retrieved_docs)} documents li√™n quan")
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi truy xu·∫•t documents: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def generate_answer_node(self, state: WorkflowState) -> WorkflowState:
        """
        B∆∞·ªõc 3.3-3.6: ƒê√°nh gi√°, T·ªïng h·ª£p v√† T·∫°o c√¢u tr·∫£ l·ªùi
        """
        try:
            state["step"] = "T·∫°o c√¢u tr·∫£ l·ªùi"
            print("ü§ñ T·∫°o c√¢u tr·∫£ l·ªùi v·ªõi RAG Agent...")
            
            # S·ª≠ d·ª•ng RAG Agent ƒë·ªÉ x·ª≠ l√Ω
            result = self.rag_agent.process_query(
                state["query"], 
                state["retrieved_documents"]
            )
            
            # C·∫≠p nh·∫≠t state v·ªõi k·∫øt qu·∫£
            state["answer"] = result["answer"]
            state["sources"] = result["sources"]
            state["relevant_docs_count"] = result["relevant_documents_count"]
            state["step"] = "Ho√†n th√†nh"
            
            print("‚úÖ ƒê√£ t·∫°o c√¢u tr·∫£ l·ªùi th√†nh c√¥ng")
            return state
            
        except Exception as e:
            state["error"] = f"L·ªói khi t·∫°o c√¢u tr·∫£ l·ªùi: {str(e)}"
            state["step"] = "L·ªói"
            return state
    
    def handle_error_node(self, state: WorkflowState) -> WorkflowState:
        """
        Node x·ª≠ l√Ω l·ªói
        """
        print(f"‚ùå X·ª≠ l√Ω l·ªói: {state.get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}")
        state["answer"] = f"Xin l·ªói, ƒë√£ x·∫£y ra l·ªói: {state.get('error', 'L·ªói kh√¥ng x√°c ƒë·ªãnh')}"
        return state
    
    def run_document_processing(self, pdf_paths: List[str]) -> Dict:
        """
        Ch·∫°y workflow cho vi·ªác x·ª≠ l√Ω documents (Giai ƒëo·∫°n 1)
        """
        print("üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω documents...")
        
        initial_state = {
            "pdf_paths": pdf_paths,
            "query": "",
            "step": "B·∫Øt ƒë·∫ßu",
            "messages": []
        }
        
        # Ch·ªâ ch·∫°y c√°c steps x·ª≠ l√Ω documents
        result = self.workflow.invoke(initial_state)
        
        return {
            "status": "success" if result.get("step") != "L·ªói" else "error",
            "step": result.get("step"),
            "error": result.get("error"),
            "documents_processed": len(result.get("documents", []))
        }
    
    def run_query(self, query: str, pdf_paths: List[str] = None) -> Dict:
        """
        Ch·∫°y workflow cho vi·ªác tr·∫£ l·ªùi c√¢u h·ªèi (Giai ƒëo·∫°n 2)
        """
        print(f"üîÑ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω c√¢u h·ªèi: {query}")
        
        initial_state = {
            "query": query,
            "pdf_paths": pdf_paths or [],
            "step": "B·∫Øt ƒë·∫ßu",
            "messages": []
        }
        
        # Ch·∫°y full workflow
        result = self.workflow.invoke(initial_state)
        
        return {
            "query": query,
            "answer": result.get("answer", ""),
            "sources": result.get("sources", []),
            "relevant_docs_count": result.get("relevant_docs_count", 0),
            "status": "success" if result.get("step") != "L·ªói" else "error",
            "error": result.get("error"),
            "step": result.get("step")
        } 