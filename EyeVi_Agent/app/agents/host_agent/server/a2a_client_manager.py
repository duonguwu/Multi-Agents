"""
A2A Client Manager - Qu·∫£n l√Ω c√°c A2A clients cho c√°c agent kh√°c nhau
"""

import asyncio
import logging
import httpx
import os
import json
from typing import Dict, Any, Optional, List
from datetime import datetime
from uuid import uuid4

import aioredis
from a2a.client import A2AClient, A2ACardResolver
from a2a.types import SendMessageRequest, SendStreamingMessageRequest, MessageSendParams

logger = logging.getLogger(__name__)

class FileInfo:
    """Class ƒë·ªÉ represent file information"""
    def __init__(self, name: str, mime_type: str, data: str):
        self.name = name
        self.mime_type = mime_type
        self.data = data  # base64 encoded

class ChatHistory:
    """Qu·∫£n l√Ω l·ªãch s·ª≠ chat cho m·ªói session"""
    
    def __init__(self):
        self.messages: List[Dict[str, Any]] = []
        self.created_at = datetime.now()
        self.last_updated = datetime.now()
    
    def add_message(self, role: str, content: str, agent_used: Optional[str] = None, user_id: Optional[str] = None):
        """Th√™m message v√†o l·ªãch s·ª≠"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "message_id": uuid4().hex
        }
        if agent_used:
            message["agent_used"] = agent_used
        if user_id:
            message["user_id"] = user_id
            
        self.messages.append(message)
        self.last_updated = datetime.now()
    
    def get_recent_messages(self, limit: int = 10) -> List[Dict[str, Any]]:
        """L·∫•y c√°c message g·∫ßn ƒë√¢y"""
        return self.messages[-limit:] if self.messages else []
    
    def get_context_string(self, limit: int = 5) -> str:
        """T·∫°o context string t·ª´ l·ªãch s·ª≠ chat"""
        recent_messages = self.get_recent_messages(limit)
        context_parts = []
        
        for msg in recent_messages:
            role_display = "User" if msg["role"] == "user" else "Assistant"
            if msg.get("agent_used"):
                role_display += f" ({msg['agent_used']})"
            context_parts.append(f"{role_display}: {msg['content']}")
        
        return "\n".join(context_parts) if context_parts else ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize ChatHistory th√†nh dict ƒë·ªÉ l∆∞u v√†o Redis"""
        return {
            "messages": self.messages,
            "created_at": self.created_at.isoformat(),
            "last_updated": self.last_updated.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ChatHistory':
        """Deserialize t·ª´ dict trong Redis"""
        chat_history = cls()
        chat_history.messages = data.get("messages", [])
        chat_history.created_at = datetime.fromisoformat(data.get("created_at", datetime.now().isoformat()))
        chat_history.last_updated = datetime.fromisoformat(data.get("last_updated", datetime.now().isoformat()))
        return chat_history

class A2AAgentClient:
    """Wrapper class cho m·ªôt A2A client c·ª• th·ªÉ"""
    
    def __init__(self, agent_name: str, base_url: str):
        self.agent_name = agent_name
        self.base_url = base_url
        self.httpx_client = None
        self.a2a_client = None
        self.agent_card = None
        self.is_initialized = False
        self.last_health_check = None
        self.is_healthy = False

    async def initialize(self):
        """Kh·ªüi t·∫°o A2A client"""
        if self.is_initialized:
            return True
            
        try:
            logger.info(f"üîÑ Kh·ªüi t·∫°o A2A client cho {self.agent_name} t·∫°i {self.base_url}")
            
            # T·∫°o httpx client
            self.httpx_client = httpx.AsyncClient(timeout=30.0)
            
            # Kh·ªüi t·∫°o A2ACardResolver ƒë·ªÉ fetch agent card
            resolver = A2ACardResolver(
                httpx_client=self.httpx_client,
                base_url=self.base_url
            )
            
            # Fetch agent card
            self.agent_card = await resolver.get_agent_card()
            
            # Kh·ªüi t·∫°o A2A client v·ªõi agent card
            self.a2a_client = A2AClient(
                httpx_client=self.httpx_client,
                agent_card=self.agent_card
            )
            
            self.is_initialized = True
            self.is_healthy = True
            self.last_health_check = datetime.now()
            
            logger.info(f"‚úÖ {self.agent_name} A2A client kh·ªüi t·∫°o th√†nh c√¥ng")
            logger.info(f"   - Name: {self.agent_card.name}")
            logger.info(f"   - Description: {self.agent_card.description}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói kh·ªüi t·∫°o A2A client cho {self.agent_name}: {e}")
            self.is_healthy = False
            return False

    async def send_message(self, message: str, context: Optional[str] = None, files: Optional[List[Any]] = None, user_id: Optional[str] = None) -> str:
        """G·ª≠i message t·ªõi agent qua A2A, c√≥ th·ªÉ k√®m files"""
        if not self.is_initialized:
            success = await self.initialize()
            if not success:
                raise Exception(f"Kh√¥ng th·ªÉ kh·ªüi t·∫°o A2A client cho {self.agent_name}")
        
        try:
            # Chu·∫©n b·ªã message v·ªõi context n·∫øu c√≥
            full_message = message
            if context:
                full_message = f"Context t·ª´ cu·ªôc h·ªôi tho·∫°i tr∆∞·ªõc:\n{context}\n\nC√¢u h·ªèi hi·ªán t·∫°i:\n{message}"
            
            # Ch·ªâ th√™m th√¥ng tin user_id v√†o message khi g·ªçi t·ªõi Order Agent
            if user_id and self.agent_name == "Order Agent":
                full_message = f"User ID: {user_id}\n\n{full_message}"
            
            # Chu·∫©n b·ªã parts cho message
            parts = []
            
            # Th√™m ph·∫ßn text
            if full_message:
                parts.append({
                    'kind': 'text', 
                    'text': full_message
                })
            
            # Th√™m files n·∫øu c√≥
            if files:
                for file_info in files:
                    parts.append({
                        'kind': 'file',
                        'file': {
                            'name': file_info.name,
                            'mimeType': file_info.mime_type,
                            'bytes': file_info.data  # base64 encoded
                        }
                    })
                    logger.info(f"üìé Th√™m file v√†o message: {file_info.name} ({file_info.mime_type})")
            
            # Chu·∫©n b·ªã message payload theo A2A format
            send_message_payload: Dict[str, Any] = {
                'message': {
                    'role': 'user',
                    'parts': parts,
                    'messageId': uuid4().hex,
                },
            }
            
            # Ch·ªâ th√™m user_id v√†o metadata khi g·ªçi t·ªõi Order Agent
            if user_id and self.agent_name == "Order Agent":
                send_message_payload['message']['metadata'] = {'user_id': user_id}
            
            if files:
                logger.info(f"üì§ G·ª≠i message v·ªõi {len(files)} files t·ªõi {self.agent_name}: {message[:100]}...")
            else:
                if user_id and self.agent_name == "Order Agent":
                    logger.info(f"üì§ G·ª≠i message t·ªõi {self.agent_name} v·ªõi User ID {user_id}: {message[:100]}...")
                else:
                    logger.info(f"üì§ G·ª≠i message t·ªõi {self.agent_name} qua A2A: {message[:100]}...")
            
            # T·∫°o request
            request = SendMessageRequest(
                id=str(uuid4()),
                params=MessageSendParams(**send_message_payload)
            )
            
            # G·ª≠i message
            response = await self.a2a_client.send_message(
                request=request, 
                http_kwargs={"timeout": None}
            )
            
            # Parse response
            response_data = response.model_dump(mode='json', exclude_none=True)
            
            # Extract content t·ª´ response
            content = ""
            if 'result' in response_data:
                result = response_data['result']
                if 'parts' in result:
                    for part in result['parts']:
                        if part.get('kind') == 'text':
                            content += part.get('text', '')
            
            if not content:
                content = "Kh√¥ng c√≥ response t·ª´ agent"
            
            logger.info(f"üì• Nh·∫≠n response t·ª´ {self.agent_name}: {content[:100]}...")
            return content
            
        except Exception as e:
            error_msg = f"L·ªói khi g·ª≠i message t·ªõi {self.agent_name}: {str(e)}"
            logger.error(error_msg)
            self.is_healthy = False
            raise Exception(error_msg)

    async def health_check(self) -> bool:
        """Ki·ªÉm tra health c·ªßa agent"""
        try:
            if not self.httpx_client:
                return False
                
            # Ki·ªÉm tra endpoint /.well-known/agent.json
            response = await self.httpx_client.get(
                f"{self.base_url}/.well-known/agent.json",
                timeout=5.0
            )
            
            self.is_healthy = response.status_code == 200
            self.last_health_check = datetime.now()
            
            return self.is_healthy
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Health check failed cho {self.agent_name}: {e}")
            self.is_healthy = False
            return False

    async def close(self):
        """ƒê√≥ng connections"""
        try:
            if self.httpx_client:
                await self.httpx_client.aclose()
            logger.info(f"‚úÖ ƒê√£ ƒë√≥ng A2A client cho {self.agent_name}")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi ƒë√≥ng A2A client cho {self.agent_name}: {e}")

class A2AClientManager:
    """Qu·∫£n l√Ω t·∫•t c·∫£ A2A clients cho c√°c agents kh√°c nhau"""
    
    def __init__(self):
        self.agents: Dict[str, A2AAgentClient] = {}
        self.redis_client: Optional[aioredis.Redis] = None
        self.chat_histories: Dict[str, ChatHistory] = {}  # Fallback cho backward compatibility
        
        # C·∫•u h√¨nh Redis
        self.redis_config = {
            "host": os.getenv("REDIS_HOST", "localhost"),
            "port": int(os.getenv("REDIS_PORT", "6379")),
            "password": os.getenv("REDIS_PASSWORD") or None,
            "db": int(os.getenv("REDIS_DB", "0"))
        }
        
        # C·∫•u h√¨nh c√°c agents t·ª´ environment variables
        self.agents_config = {
            "Advisor Agent": {
                "url": os.getenv("ADVISOR_AGENT_URL", "http://localhost:10001"),
                "enabled": True
            },
            "Search Agent": {
                "url": os.getenv("SEARCH_AGENT_URL", "http://localhost:10002"),
                "enabled": True
            },
            "Order Agent": {
                "url": os.getenv("ORDER_AGENT_URL", "http://localhost:10003"),
                "enabled": True
            }
        }

    async def initialize(self):
        """Kh·ªüi t·∫°o t·∫•t c·∫£ A2A clients v√† Redis connection"""
        logger.info("üöÄ Kh·ªüi t·∫°o A2A Client Manager...")
        
        # Kh·ªüi t·∫°o Redis connection
        try:
            self.redis_client = aioredis.from_url(
                f"redis://{self.redis_config['host']}:{self.redis_config['port']}/{self.redis_config['db']}",
                password=self.redis_config['password'],
                decode_responses=True
            )
            # Test connection
            await self.redis_client.ping()
            logger.info("‚úÖ Redis connection kh·ªüi t·∫°o th√†nh c√¥ng")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi kh·ªüi t·∫°o Redis connection: {e}")
            logger.warning("‚ö†Ô∏è S·∫Ω s·ª≠ d·ª•ng in-memory storage cho chat history")
            self.redis_client = None
        
        for agent_name, config in self.agents_config.items():
            if config["enabled"]:
                self.agents[agent_name] = A2AAgentClient(
                    agent_name=agent_name,
                    base_url=config["url"]
                )
                
                # Th·ª≠ kh·ªüi t·∫°o ngay (kh√¥ng ch·∫∑n n·∫øu agent kh√¥ng available)
                try:
                    await self.agents[agent_name].initialize()
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o {agent_name}: {e}")
        
        logger.info(f"‚úÖ A2A Client Manager ƒë√£ kh·ªüi t·∫°o v·ªõi {len(self.agents)} agents")

    async def send_message_to_agent(
        self, 
        agent_name: str, 
        message: str,
        user_id: Optional[str] = None,
        session_id: Optional[str] = None,
        files: Optional[List[Any]] = None
    ) -> str:
        """G·ª≠i message t·ªõi agent c·ª• th·ªÉ, c√≥ th·ªÉ k√®m files"""
        if agent_name not in self.agents:
            raise ValueError(f"Agent '{agent_name}' kh√¥ng t·ªìn t·∫°i")
        
        agent_client = self.agents[agent_name]
        
        # L·∫•y context t·ª´ chat history (s·ª≠ d·ª•ng Redis n·∫øu c√≥ user_id)
        context = None
        if session_id:
            if user_id and self.redis_client:
                chat_history = await self._load_chat_history_from_redis(user_id, session_id)
                if chat_history:
                    context = chat_history.get_context_string()
            elif session_id in self.chat_histories:
                context = self.chat_histories[session_id].get_context_string()
        
        # G·ª≠i message v·ªõi files v√† user_id
        response = await agent_client.send_message(message, context, files, user_id)
        
        # L∆∞u v√†o chat history
        if session_id:
            # T·∫°o message content bao g·ªìm th√¥ng tin v·ªÅ files
            message_content = message
            if files:
                file_names = [f.name for f in files]
                message_content += f" [ƒê√≠nh k√®m: {', '.join(file_names)}]"
            
            if user_id and self.redis_client:
                # S·ª≠ d·ª•ng Redis
                chat_history = await self._ensure_chat_history_with_redis(user_id, session_id)
                chat_history.add_message("user", message_content, user_id=user_id)
                chat_history.add_message("assistant", response, agent_name)
                await self._save_chat_history_to_redis(user_id, session_id, chat_history)
            else:
                # Fallback to in-memory
                self._ensure_chat_history(session_id)
                self.chat_histories[session_id].add_message("user", message_content, user_id=user_id)
                self.chat_histories[session_id].add_message("assistant", response, agent_name)
        
        return response

    def _ensure_chat_history(self, session_id: str):
        """ƒê·∫£m b·∫£o chat history t·ªìn t·∫°i cho session"""
        if session_id not in self.chat_histories:
            self.chat_histories[session_id] = ChatHistory()

    def _get_redis_key(self, user_id: str, session_id: str) -> str:
        """T·∫°o Redis key cho chat history"""
        return f"chat_history:{user_id}:{session_id}"
    
    def _get_user_sessions_pattern(self, user_id: str) -> str:
        """T·∫°o pattern ƒë·ªÉ t√¨m t·∫•t c·∫£ sessions c·ªßa user"""
        return f"chat_history:{user_id}:*"
    
    async def _save_chat_history_to_redis(self, user_id: str, session_id: str, chat_history: ChatHistory):
        """L∆∞u chat history v√†o Redis"""
        if not self.redis_client:
            return
        
        try:
            redis_key = self._get_redis_key(user_id, session_id)
            data = json.dumps(chat_history.to_dict())
            await self.redis_client.set(redis_key, data, ex=86400*7)  # Expire sau 7 ng√†y
            logger.debug(f"üíæ L∆∞u chat history v√†o Redis: {redis_key}")
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi l∆∞u chat history v√†o Redis: {e}")
    
    async def _load_chat_history_from_redis(self, user_id: str, session_id: str) -> Optional[ChatHistory]:
        """T·∫£i chat history t·ª´ Redis"""
        if not self.redis_client:
            return None
        
        try:
            redis_key = self._get_redis_key(user_id, session_id)
            data = await self.redis_client.get(redis_key)
            if data:
                chat_data = json.loads(data)
                return ChatHistory.from_dict(chat_data)
            return None
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫£i chat history t·ª´ Redis: {e}")
            return None
    
    async def _ensure_chat_history_with_redis(self, user_id: str, session_id: str) -> ChatHistory:
        """ƒê·∫£m b·∫£o chat history t·ªìn t·∫°i (s·ª≠ d·ª•ng Redis n·∫øu c√≥)"""
        if self.redis_client and user_id:
            # Th·ª≠ t·∫£i t·ª´ Redis tr∆∞·ªõc
            chat_history = await self._load_chat_history_from_redis(user_id, session_id)
            if chat_history:
                return chat_history
            
            # T·∫°o m·ªõi n·∫øu kh√¥ng t√¨m th·∫•y
            chat_history = ChatHistory()
            await self._save_chat_history_to_redis(user_id, session_id, chat_history)
            return chat_history
        else:
            # Fallback to in-memory
            if session_id not in self.chat_histories:
                self.chat_histories[session_id] = ChatHistory()
            return self.chat_histories[session_id]

    async def get_available_agents(self) -> List[str]:
        """L·∫•y danh s√°ch agents kh·∫£ d·ª•ng"""
        available = []
        for agent_name, agent_client in self.agents.items():
            if agent_client.is_healthy:
                available.append(agent_name)
            else:
                # Th·ª≠ health check l·∫ßn n·ªØa
                is_healthy = await agent_client.health_check()
                if is_healthy:
                    available.append(agent_name)
        
        return available

    async def health_check_all(self) -> Dict[str, Any]:
        """Health check t·∫•t c·∫£ agents"""
        results = {}
        
        for agent_name, agent_client in self.agents.items():
            is_healthy = await agent_client.health_check()
            results[agent_name] = {
                "healthy": is_healthy,
                "url": agent_client.base_url,
                "initialized": agent_client.is_initialized,
                "last_check": agent_client.last_health_check.isoformat() if agent_client.last_health_check else None
            }
        
        return results

    async def get_chat_history(self, user_id: str, session_id: str) -> Optional[ChatHistory]:
        """L·∫•y chat history cho session (∆∞u ti√™n Redis n·∫øu c√≥ user_id)"""
        if user_id and self.redis_client:
            return await self._load_chat_history_from_redis(user_id, session_id)
        else:
            return self.chat_histories.get(session_id)
    
    def get_chat_history_fallback(self, session_id: str) -> Optional[ChatHistory]:
        """L·∫•y chat history t·ª´ memory (cho backward compatibility)"""
        return self.chat_histories.get(session_id)

    async def clear_chat_history(self, user_id: str, session_id: str):
        """X√≥a chat history cho session"""
        if user_id and self.redis_client:
            try:
                redis_key = self._get_redis_key(user_id, session_id)
                await self.redis_client.delete(redis_key)
                logger.info(f"üóëÔ∏è ƒê√£ x√≥a chat history t·ª´ Redis: {redis_key}")
            except Exception as e:
                logger.error(f"‚ùå L·ªói khi x√≥a chat history t·ª´ Redis: {e}")
        
        # C≈©ng x√≥a t·ª´ memory n·∫øu c√≥
        if session_id in self.chat_histories:
            del self.chat_histories[session_id]
    
    def clear_chat_history_fallback(self, session_id: str):
        """X√≥a chat history t·ª´ memory (cho backward compatibility)"""
        if session_id in self.chat_histories:
            del self.chat_histories[session_id]
    
    async def get_user_sessions(self, user_id: str) -> List[str]:
        """L·∫•y danh s√°ch t·∫•t c·∫£ sessions c·ªßa user t·ª´ Redis"""
        if not user_id or not self.redis_client:
            return []
        
        try:
            pattern = self._get_user_sessions_pattern(user_id)
            keys = await self.redis_client.keys(pattern)
            # Extract session_id t·ª´ keys
            sessions = []
            for key in keys:
                # Format: chat_history:user_id:session_id
                parts = key.split(":")
                if len(parts) >= 3:
                    session_id = ":".join(parts[2:])  # Handle session_id c√≥ th·ªÉ ch·ª©a ":"
                    sessions.append(session_id)
            return sessions
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi l·∫•y user sessions t·ª´ Redis: {e}")
            return []

    async def cleanup(self):
        """Cleanup t·∫•t c·∫£ resources"""
        logger.info("üîÑ Cleanup A2A Client Manager...")
        
        for agent_name, agent_client in self.agents.items():
            await agent_client.close()
        
        # ƒê√≥ng Redis connection
        if self.redis_client:
            try:
                await self.redis_client.close()
                logger.info("‚úÖ Redis connection ƒë√£ ƒë√≥ng")
            except Exception as e:
                logger.error(f"‚ùå L·ªói khi ƒë√≥ng Redis connection: {e}")
        
        # Clear chat histories (optional)
        self.chat_histories.clear()
        
        logger.info("‚úÖ A2A Client Manager cleanup ho√†n t·∫•t") 