"use client";

import React, { useState, useEffect, useRef, createContext, useContext, useImperativeHandle, forwardRef } from "react";
import ChatHeader from "./chat-header";
import ChatMessages from "./chat-messages";
import ChatInput, { ChatInputRef } from "./chat-input";
import { useChatApi, ProductData, OrderData } from "@/hooks/useChatApi";

// T·∫°o context ƒë·ªÉ truy c·∫≠p chatInputRef t·ª´ c√°c component kh√°c
interface ChatContextType {
  setChatInputMessage: (text: string) => void;
  loadHistoryBySessionId: (sessionId: string) => void;
}

export const ChatContext = createContext<ChatContextType | null>(null);

export const useChatContext = () => {
  const context = useContext(ChatContext);
  if (!context) {
    throw new Error("useChatContext must be used within a ChatContextProvider");
  }
  return context;
};

// Interface cho ChatContainer ref
export interface ChatContainerRef {
  loadHistoryBySessionId: (sessionId: string) => void;
  resetChat: () => void;
}

// Interface cho Message trong ChatContainer
interface ContainerMessage {
  id: number;
  role: "user" | "assistant";
  content: string;
  timestamp: string;
  attachments?: Array<{name: string; url: string; type: string}>;
  products?: ProductData[];
  extracted_product_ids?: string[];
  orders?: OrderData[];
  agent_used?: string;
  is_loading?: boolean;
  loading_step?: string;
}

// Interface cho Message trong ChatMessages (ƒë·ªÉ tham chi·∫øu)
interface ChatMessage {
  id: string;
  content: string;
  sender: "user" | "bot";
  timestamp: Date;
  attachments?: Array<{name: string; url: string; type: string}>;
  products?: ProductData[];
  extracted_product_ids?: string[];
  orders?: OrderData[];
  agent_used?: string;
  is_loading?: boolean;
  loading_step?: string;
}

// C√°c b∆∞·ªõc loading v√† th√¥ng b√°o t∆∞∆°ng ·ª©ng
const LOADING_STEPS = [
  "ƒêang ph√¢n t√≠ch y√™u c·∫ßu...",
  "ƒêang t√¨m ki·∫øm th√¥ng tin li√™n quan...",
  "ƒêang giao nhi·ªám v·ª• cho agent chuy√™n m√¥n...",
  "ƒêang x·ª≠ l√Ω d·ªØ li·ªáu...",
  "ƒêang t·ªïng h·ª£p th√¥ng tin...",
  "ƒêang chu·∫©n b·ªã ph·∫£n h·ªìi...",
];

const ChatContainer = forwardRef<ChatContainerRef>((_, ref) => {
  const { sendMessage, createNewSession, getChatHistoryBySessionId, isLoading, sessionId } = useChatApi();
  const [messages, setMessages] = useState<ContainerMessage[]>([]);
  const [products, setProducts] = useState<ProductData[]>([]);
  const [productIds, setProductIds] = useState<string[]>([]);
  const [loadingMessageId, setLoadingMessageId] = useState<number | null>(null);
  const [loadingStepIndex, setLoadingStepIndex] = useState(0);
  const [isViewingHistory, setIsViewingHistory] = useState(false);
  const [viewingSessionId, setViewingSessionId] = useState<string | null>(null);
  const [resetTrigger, setResetTrigger] = useState(0);

  // L∆∞u t·∫°m chat hi·ªán t·∫°i khi xem l·ªãch s·ª≠
  const [tempCurrentMessages, setTempCurrentMessages] = useState<ContainerMessage[]>([]);
  const [tempCurrentProducts, setTempCurrentProducts] = useState<ProductData[]>([]);
  const [tempCurrentProductIds, setTempCurrentProductIds] = useState<string[]>([]);

  const chatInputRef = useRef<ChatInputRef>(null);
  const previousSessionIdRef = useRef<string | null>(null);

  // Reset messages khi sessionId thay ƒë·ªïi (t·∫°o session m·ªõi)
  useEffect(() => {
    console.log("SessionId effect triggered:", {
      sessionId,
      previousSessionId: previousSessionIdRef.current,
      isViewingHistory,
      messagesLength: messages.length
    });

    if (sessionId && sessionId !== previousSessionIdRef.current && !isViewingHistory) {
      console.log("üîÑ Resetting chat container - Session changed from", previousSessionIdRef.current, "to", sessionId);

      // Reset t·∫•t c·∫£ state khi c√≥ session m·ªõi
      setMessages([]);
      setProducts([]);
      setProductIds([]);
      setLoadingMessageId(null);

      // C·∫≠p nh·∫≠t ref ƒë·ªÉ theo d√µi session hi·ªán t·∫°i
      previousSessionIdRef.current = sessionId;
    }
  }, [sessionId, isViewingHistory]);

  // Cleanup object URLs khi component unmount (kh√¥ng cleanup khi messages thay ƒë·ªïi)
  useEffect(() => {
    return () => {
      messages.forEach(msg => {
        if (msg.attachments) {
          msg.attachments.forEach(attachment => {
            if (attachment.url.startsWith('blob:')) {
              URL.revokeObjectURL(attachment.url);
            }
          });
        }
      });
    };
  }, []); // Ch·ªâ cleanup khi component unmount

  // Kh·ªüi t·∫°o tin nh·∫Øn ch√†o m·ª´ng khi c√≥ sessionId v√† messages r·ªóng
  useEffect(() => {
    console.log("Welcome message effect triggered:", {
      sessionId,
      isViewingHistory,
      messagesLength: messages.length,
      resetTrigger
    });

    if (sessionId && !isViewingHistory && messages.length === 0) {
      console.log("‚úÖ Adding welcome message");
      setMessages([
        {
          id: 1,
          role: "assistant",
          content: "Xin ch√†o! T√¥i l√† EyeVi, tr·ª£ l√Ω ·∫£o h·ªó tr·ª£ b·∫°n mua s·∫Øm k√≠nh m·∫Øt. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?",
          timestamp: new Date().toISOString(),
        },
      ]);
    }
  }, [sessionId, isViewingHistory, messages.length, resetTrigger]);

  // Function ƒë·ªÉ reset chat
  const resetChat = () => {
    console.log("üîÑ Manual reset chat triggered");
    setMessages([]);
    setProducts([]);
    setProductIds([]);
    setLoadingMessageId(null);
    setIsViewingHistory(false);
    setViewingSessionId(null);

    // Clear temp data
    setTempCurrentMessages([]);
    setTempCurrentProducts([]);
    setTempCurrentProductIds([]);

    setResetTrigger(prev => prev + 1);
  };

  // Function ƒë·ªÉ load l·ªãch s·ª≠ t·ª´ session_id c·ª• th·ªÉ
  const loadHistoryBySessionId = async (targetSessionId: string) => {
    try {
      console.log("üìö Loading history for session:", targetSessionId);

      // L∆∞u t·∫°m chat hi·ªán t·∫°i tr∆∞·ªõc khi xem l·ªãch s·ª≠
      console.log("üíæ Saving current chat temporarily");
      setTempCurrentMessages([...messages]);
      setTempCurrentProducts([...products]);
      setTempCurrentProductIds([...productIds]);

      setIsViewingHistory(true);
      setViewingSessionId(targetSessionId);

      const historyMessages = await getChatHistoryBySessionId(targetSessionId);

      // Chuy·ªÉn ƒë·ªïi format t·ª´ API th√†nh ContainerMessage
      const formattedMessages: ContainerMessage[] = historyMessages.map((msg: any, index: number) => ({
        id: index + 1,
        role: msg.sender_type === "user" ? "user" : "assistant",
        content: msg.message_content,
        timestamp: msg.created_at,
        products: msg.metadata?.products,
        extracted_product_ids: msg.metadata?.extracted_product_ids,
        orders: msg.metadata?.orders,
        agent_used: msg.metadata?.agent_used,
        is_loading: false,
      }));

      setMessages(formattedMessages);
      setProducts([]);
      setProductIds([]);
      setLoadingMessageId(null);

      console.log("‚úÖ History loaded, current chat saved temporarily");
    } catch (error) {
      console.error("L·ªói khi load l·ªãch s·ª≠:", error);
    }
  };

  // Expose methods to parent components via ref
  useImperativeHandle(ref, () => ({
    loadHistoryBySessionId,
    resetChat
  }));

  // T·∫°o context value
  const chatContextValue = {
    setChatInputMessage: (text: string) => {
      chatInputRef.current?.setInputMessage(text);
      chatInputRef.current?.focusInput();
    },
    loadHistoryBySessionId
  };

  // T·∫°o session m·ªõi khi component mount n·∫øu ch∆∞a c√≥
  useEffect(() => {
    if (!sessionId) {
      createNewSession();
    }
  }, [sessionId, createNewSession]);
  
  // Hi·ªáu ·ª©ng thay ƒë·ªïi th√¥ng b√°o loading
  useEffect(() => {
    let intervalId: NodeJS.Timeout | null = null;
    
    if (loadingMessageId !== null) {
      intervalId = setInterval(() => {
        setLoadingStepIndex((prev) => (prev + 1) % LOADING_STEPS.length);
        
        setMessages((prevMessages) => 
          prevMessages.map((msg) => 
            msg.id === loadingMessageId 
              ? { ...msg, loading_step: LOADING_STEPS[loadingStepIndex] }
              : msg
          )
        );
      }, 1400); // Thay ƒë·ªïi th√¥ng b√°o m·ªói 2 gi√¢y
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [loadingMessageId, loadingStepIndex]);

  const handleSendMessage = async (message: string, attachments?: File[]) => {
    // T·∫°o attachment URLs cho preview
    const attachmentData = attachments?.map(file => ({
      name: file.name,
      url: URL.createObjectURL(file),
      type: file.type
    })) || [];

    // Th√™m tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng v√†o danh s√°ch
    const userMessage: ContainerMessage = {
      id: messages.length + 1,
      role: "user",
      content: message,
      timestamp: new Date().toISOString(),
      attachments: attachmentData,
    };

    setMessages((prev) => [...prev, userMessage]);
    
    // Th√™m tin nh·∫Øn loading
    const loadingMessageId = messages.length + 2;
    const loadingMessage: ContainerMessage = {
      id: loadingMessageId,
      role: "assistant",
      content: "",
      timestamp: new Date().toISOString(),
      is_loading: true,
      loading_step: LOADING_STEPS[0],
    };
    
    setMessages((prev) => [...prev, loadingMessage]);
    setLoadingMessageId(loadingMessageId);
    setLoadingStepIndex(0);
    
    try {
      // G·ª≠i tin nh·∫Øn ƒë·∫øn API
      const response = await sendMessage(message, attachments);

      // Logic ∆∞u ti√™n:
      // 1. N·∫øu c√≥ orders ‚Üí ch·ªâ hi·ªÉn th·ªã orders
      // 2. N·∫øu c√≥ data (products) ‚Üí hi·ªÉn th·ªã data, kh√¥ng hi·ªÉn th·ªã extracted_product_ids
      // 3. N·∫øu ch·ªâ c√≥ extracted_product_ids ‚Üí hi·ªÉn th·ªã extracted_product_ids
      const hasOrders = response.orders && response.orders.length > 0;
      const hasProducts = response.data && response.data.length > 0;
      const hasExtractedIds = response.extracted_product_ids && response.extracted_product_ids.length > 0;

      // X√≥a tin nh·∫Øn loading v√† th√™m tin nh·∫Øn ph·∫£n h·ªìi t·ª´ API
      const botReply: ContainerMessage = {
        id: loadingMessageId,
        role: "assistant",
        content: response.response,
        timestamp: new Date().toISOString(),
        products: !hasOrders && hasProducts ? response.data : undefined,
        extracted_product_ids: !hasOrders && !hasProducts && hasExtractedIds ? response.extracted_product_ids : undefined,
        orders: hasOrders ? response.orders : undefined,
        agent_used: response.agent_used,
        is_loading: false,
      };

      setMessages((prev) =>
        prev.map((msg) => (msg.id === loadingMessageId ? botReply : msg))
      );
      setLoadingMessageId(null);

      // Logic ∆∞u ti√™n state update:
      // 1. N·∫øu c√≥ orders ‚Üí clear products
      // 2. N·∫øu c√≥ data (products) ‚Üí set products, clear product IDs
      // 3. N·∫øu ch·ªâ c√≥ extracted_product_ids ‚Üí set product IDs, clear products
      if (hasOrders) {
        setProducts([]); // Clear products khi c√≥ orders
        setProductIds([]); // Clear product IDs khi c√≥ orders
      } else if (hasProducts) {
        setProducts(response.data!); // Set products khi c√≥ data
        setProductIds([]); // Clear product IDs khi c√≥ products
      } else if (hasExtractedIds) {
        setProducts([]); // Clear products khi ch·ªâ c√≥ extracted IDs
        setProductIds(response.extracted_product_ids!); // Set product IDs
      } else {
        setProducts([]); // Clear t·∫•t c·∫£ n·∫øu kh√¥ng c√≥ g√¨
        setProductIds([]);
      }
    } catch (error) {
      console.error("L·ªói khi g·ª≠i tin nh·∫Øn:", error);
      
      // X√≥a tin nh·∫Øn loading v√† th√™m tin nh·∫Øn l·ªói
      const errorMessage: ContainerMessage = {
        id: loadingMessageId,
        role: "assistant",
        content: "Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω tin nh·∫Øn c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.",
        timestamp: new Date().toISOString(),
        is_loading: false,
      };
      
      setMessages((prev) => 
        prev.map((msg) => (msg.id === loadingMessageId ? errorMessage : msg))
      );
      setLoadingMessageId(null);
    }
  };

  // Chuy·ªÉn ƒë·ªïi t·ª´ ContainerMessage sang ƒë·ªãnh d·∫°ng m√† ChatMessages mong ƒë·ª£i
  const transformMessages = (): ChatMessage[] => {
    return messages.map(msg => {
      // Log ƒë·ªÉ debug
      console.log("Transforming message:", msg);
      if (msg.extracted_product_ids) {
        console.log("Found extracted_product_ids:", msg.extracted_product_ids);
      }

      return {
        id: msg.id.toString(),
        content: msg.content,
        sender: msg.role === "user" ? "user" : "bot",
        timestamp: new Date(msg.timestamp),
        attachments: msg.attachments || [],
        products: msg.products,
        extracted_product_ids: msg.extracted_product_ids,
        orders: msg.orders,
        agent_used: msg.agent_used,
        is_loading: msg.is_loading,
        loading_step: msg.loading_step,
      };
    });
  };

  // X·ª≠ l√Ω t·∫°o cu·ªôc tr√≤ chuy·ªán m·ªõi
  const handleNewChat = async () => {
    try {
      // Reset state tr∆∞·ªõc khi t·∫°o session m·ªõi
      setIsViewingHistory(false);
      setViewingSessionId(null);

      // T·∫°o session m·ªõi v√† ƒë·ª£i k·∫øt qu·∫£
      const newSessionId = await createNewSession();
      console.log("Created new session:", newSessionId);

      if (newSessionId) {
        // Messages s·∫Ω ƒë∆∞·ª£c reset t·ª± ƒë·ªông b·ªüi useEffect khi sessionId thay ƒë·ªïi
        // Tin nh·∫Øn ch√†o m·ª´ng s·∫Ω ƒë∆∞·ª£c th√™m t·ª± ƒë·ªông sau ƒë√≥
        console.log("New chat initialized with session:", newSessionId);
      } else {
        console.error("Failed to create new session");
        // N·∫øu t·∫°o session th·∫•t b·∫°i, v·∫´n hi·ªÉn th·ªã tin nh·∫Øn ch√†o m·ª´ng
        setMessages([
          {
            id: 1,
            role: "assistant",
            content: "Xin ch√†o! T√¥i l√† EyeVi, tr·ª£ l√Ω ·∫£o h·ªó tr·ª£ b·∫°n mua s·∫Øm k√≠nh m·∫Øt. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?",
            timestamp: new Date().toISOString(),
          },
        ]);
      }
    } catch (error) {
      console.error("Error creating new chat:", error);
    }
  };

  // X·ª≠ l√Ω quay l·∫°i chat hi·ªán t·∫°i
  const handleBackToCurrentChat = async () => {
    console.log("üîô Returning to current chat");

    setIsViewingHistory(false);
    setViewingSessionId(null);
    setLoadingMessageId(null);

    // Restore chat ƒë√£ l∆∞u t·∫°m
    console.log("üì§ Restoring temporarily saved chat");
    setMessages([...tempCurrentMessages]);
    setProducts([...tempCurrentProducts]);
    setProductIds([...tempCurrentProductIds]);

    // Clear temp data
    setTempCurrentMessages([]);
    setTempCurrentProducts([]);
    setTempCurrentProductIds([]);

    console.log("‚úÖ Current chat restored");
  };

  return (
    <ChatContext.Provider value={chatContextValue}>
      <div className="flex flex-col flex-1 h-screen overflow-hidden">
        <ChatHeader
          onNewChat={handleNewChat}
          isViewingHistory={isViewingHistory}
          onBackToCurrentChat={handleBackToCurrentChat}
        />
        <div className="flex-1 overflow-hidden flex flex-col">
          <ChatMessages messages={transformMessages()} />
        </div>
        <ChatInput
          ref={chatInputRef}
          onSendMessage={handleSendMessage}
          isLoading={isLoading || loadingMessageId !== null}
          disabled={isViewingHistory}
        />
      </div>
    </ChatContext.Provider>
  );
});

ChatContainer.displayName = "ChatContainer";

export default ChatContainer;